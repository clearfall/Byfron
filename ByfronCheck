<#
.SYNOPSIS
  BYFRON System Tool - Clean UI, Async feel, Safe checks, Process Explorer installer, newui.exe detector
.AUTHOR
  Credits: Clearfall
.NOTES
  - This script detects and logs only. NO automatic deletion.
  - Logs written to C:\ToolsETA\Logs\byfron.log
#>

# ---------------------------
# Basic config & helpers
# ---------------------------

$ScriptName = "BYFRON Tool"
$LogRoot = "C:\ToolsETA\Logs"
$LogFile = Join-Path $LogRoot "byfron.log"
$ToolRoot = "C:\ToolsETA"
$ProcessExplorerFolder = Join-Path $ToolRoot "ProcessExplorer"

# Ensure folders exist
Try {
    if (-not (Test-Path $LogRoot)) { New-Item -Path $LogRoot -ItemType Directory -Force | Out-Null }
    if (-not (Test-Path $ToolRoot)) { New-Item -Path $ToolRoot -ItemType Directory -Force | Out-Null }
} catch { }

function Log-Info {
    param([string]$Message)
    $line = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [INFO]  $Message"
    Add-Content -Path $LogFile -Value $line -Force
}
function Log-Warn {
    param([string]$Message)
    $line = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [WARN]  $Message"
    Add-Content -Path $LogFile -Value $line -Force
}
function Log-Error {
    param([string]$Message)
    $line = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [ERROR] $Message"
    Add-Content -Path $LogFile -Value $line -Force
}

function Write-ColoredLine {
    param (
        [string]$Text,
        [ConsoleColor]$Color = 'White'
    )
    $oldColor = $Host.UI.RawUI.ForegroundColor
    $Host.UI.RawUI.ForegroundColor = $Color
    Write-Host $Text
    $Host.UI.RawUI.ForegroundColor = $oldColor
}

function Wait-ForEnter {
    param(
        [string]$Message = "Press Enter to Continue"
    )
    Write-ColoredLine ""
    Write-ColoredLine $Message Yellow
    while ($true) {
        if ([System.Console]::KeyAvailable) {
            $key = [System.Console]::ReadKey($true)
            if ($key.Key -eq "Enter") { break }
        }
        Start-Sleep -Milliseconds 100
    }
}

function Show-LoadingBar {
    param([int]$Cycles = 10, [int]$DelayMs = 120)
    for ($i = 0; $i -le $Cycles; $i++) {
        $percent = [int]((($i / $Cycles) * 100))
        $bars = "#" * [int](($i / $Cycles * 20))
        $spaces = " " * (20 - $bars.Length)
        Write-Host -NoNewline "`rProgress: [$bars$spaces] $percent% " -ForegroundColor White
        Start-Sleep -Milliseconds $DelayMs
    }
    Write-Host ""
}

# ---------------------------
# BYFRON animated banner
# ---------------------------

function Show-AsyncTitle {
    Clear-Host
    $frames = @("|", "/", "-", "\")
    $titleArt = @'
  ______     ________ _____   ____  _   _ 
 |  _ \ \   / /  ____|  __ \ / __ \| \ | |
 | |_) \ \_/ /| |__  | |__) | |  | |  \| |
 |  _ < \   / |  __| |  _  /| |  | | . ` |
 | |_) | | |  | |    | | \ \| |__| | |\  |
 |____/  |_|  |_|    |_|  \_\\____/|_| \_|
                                          
'@
    for ($i = 0; $i -lt 12; $i++) {
        $frame = $frames[$i % $frames.Length]
        Write-Host "`r$frame Loading BYFRON... $frame" -ForegroundColor Cyan -NoNewline
        Start-Sleep -Milliseconds 90
    }
    Clear-Host
    Write-Host $titleArt -ForegroundColor Magenta
    Write-Host "               Made by Clearfall" -ForegroundColor Yellow
    Write-Host "               Discord: Coming Soon..." -ForegroundColor DarkCyan
    Write-Host ""
    Start-Sleep -Milliseconds 350
}

# ---------------------------
# Elevation handling
# ---------------------------

function Test-IsAdmin {
    $current = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($current)
    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

function Ensure-RunningAsAdmin {
    param([switch]$RelaunchIfNotAdmin)
    if (-not (Test-IsAdmin)) {
        Write-ColoredLine "`n[WARNING] This script is NOT running with Administrator privileges." -ForegroundColor Red
        if ($RelaunchIfNotAdmin) {
            Write-ColoredLine "[INFO] Attempting to relaunch with administrator privileges..." -ForegroundColor Yellow
            Log-Warn "Script not elevated — relaunching as admin."
            # Relaunch same script with admin privileges
            try {
                $scriptPath = $MyInvocation.MyCommand.Definition
                if (-not $scriptPath) {
                    Write-ColoredLine "[ERROR] Could not determine script path for relaunch." -ForegroundColor Red
                    Log-Error "Could not determine script path for elevation."
                    return $false
                }
                $argsLine = "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`""
                Start-Process -FilePath "powershell.exe" -ArgumentList $argsLine -Verb RunAs
                Write-ColoredLine "[INFO] Relaunched — exiting current session." -ForegroundColor Cyan
                exit
            } catch {
                Write-ColoredLine "[ERROR] Elevation attempt failed: $($_.Exception.Message)" -ForegroundColor Red
                Log-Error "Elevation attempt failed: $($_.Exception.Message)"
                return $false
            }
        } else {
            Write-ColoredLine "[ACTION] Please run this script as Administrator and re-run." -ForegroundColor Yellow
            Log-Warn "Script not elevated; user was prompted to relaunch manually."
            Pause
            exit 1
        }
    } else {
        return $true
    }
}

# ---------------------------
# Utility: human-readable size
# ---------------------------
function Convert-BytesToReadable {
    param([long]$Bytes)
    if ($Bytes -ge 1PB) { "{0:N2} PB" -f ($Bytes / 1PB) }
    elseif ($Bytes -ge 1TB) { "{0:N2} TB" -f ($Bytes / 1TB) }
    elseif ($Bytes -ge 1GB) { "{0:N2} GB" -f ($Bytes / 1GB) }
    elseif ($Bytes -ge 1MB) { "{0:N2} MB" -f ($Bytes / 1MB) }
    elseif ($Bytes -ge 1KB) { "{0:N2} KB" -f ($Bytes / 1KB) }
    else { "$Bytes B" }
}

# ---------------------------
# Feature: search for newui.exe (non-destructive)
# ---------------------------
function Scan-NewUI {
    param(
        [string[]]$Roots = @("C:\"),
        [switch]$FastMode
    )

    $found = @()
    $rootsToScan = @()

    foreach ($r in $Roots) {
        try {
            if (Test-Path $r) { $rootsToScan += $r }
        } catch {}
    }

    if ($rootsToScan.Count -eq 0) {
        Write-ColoredLine "[WARN] No valid roots to scan." Yellow
        return $found
    }

    Write-ColoredLine "`nScanning for 'newui.exe' (read-only)... This may take a while on large drives." Cyan
    Log-Info "Starting newui.exe scan on roots: $($rootsToScan -join ', ')"

    foreach ($root in $rootsToScan) {
        try {
            # use Get-ChildItem with error handling; optionally restrict depth in fast mode
            if ($FastMode) {
                $items = Get-ChildItem -Path $root -Filter "newui.exe" -File -ErrorAction SilentlyContinue -Force
                foreach ($i in $items) {
                    $found += [PSCustomObject]@{ Path = $i.FullName; Size = $i.Length; LastWrite = $i.LastWriteTime }
                }
            } else {
                # recursive could be slow; handle access-denied quietly
                $gciParams = @{
                    Path = $root
                    Filter = "newui.exe"
                    Recurse = $true
                    File = $true
                    ErrorAction = 'SilentlyContinue'
                    Force = $true
                }
                try {
                    $items = Get-ChildItem @gciParams
                    foreach ($i in $items) {
                        $found += [PSCustomObject]@{ Path = $i.FullName; Size = $i.Length; LastWrite = $i.LastWriteTime }
                    }
                } catch {
                    # fallback: search top-level then important folders
                    Write-ColoredLine "[INFO] Full recursion at $root failed (insufficient access). Scanning common locations." Yellow
                    Log-Warn "Full recursion at $root failed: $($_.Exception.Message)"
                    $common = @("C:\Program Files", "C:\Program Files (x86)", "C:\Users", "C:\Windows\Temp")
                    foreach ($c in $common) {
                        if (Test-Path $c) {
                            $items2 = Get-ChildItem -Path $c -Filter "newui.exe" -Recurse -File -ErrorAction SilentlyContinue -Force
                            foreach ($i in $items2) {
                                $found += [PSCustomObject]@{ Path = $i.FullName; Size = $i.Length; LastWrite = $i.LastWriteTime }
                            }
                        }
                    }
                }
            }
        } catch {
            Log-Warn "Error scanning $root: $($_.Exception.Message)"
        }
    }

    if ($found.Count -gt 0) {
        Write-ColoredLine "`n[ALERT] Found newui.exe files:" Red
        foreach ($f in $found) {
            $size = Convert-BytesToReadable -Bytes $f.Size
            Write-ColoredLine " • $($f.Path) (Size: $size, Modified: $($f.LastWrite))" Yellow
            Log-Warn "Found newui.exe at $($f.Path) Size=$($f.Size) LastWrite=$($f.LastWrite)"
        }
    } else {
        Write-ColoredLine "`n[OK] No newui.exe files found on scanned roots." Green
        Log-Info "newui.exe scan completed: none found."
    }

    return $found
}

# ---------------------------
# System Check (safe, non-destructive)
# ---------------------------
function Run-SystemCheck {
    Clear-Host
    Show-AsyncTitle
    Write-ColoredLine "Step 1 of 1: SYSTEM Check (safe, read-only)" White
    Write-ColoredLine "INSTRUCTION: This will collect system info and scan for suspicious items (no deletion)." Yellow
    Write-Host ""
    Show-LoadingBar -Cycles 8 -DelayMs 90

    # Prepare result containers
    $modulesOutput = @()
    $windowsOutput = @()
    $memoryIntegrityOutput = @()
    $defenderOutput = @()
    $exclusionsOutput = @()
    $threatsOutput = @()
    $powershellSigOutput = @()
    $newuiFindings = @()

    # 1) OS check
    try {
        $os = Get-CimInstance Win32_OperatingSystem -ErrorAction Stop
        $windowsOutput += "SUCCESS: Running on Windows: $($os.Caption) (Build $($os.BuildNumber))."
        Log-Info "OS: $($os.Caption) Build $($os.BuildNumber)"
    } catch {
        $windowsOutput += "FAILURE: OS check failed: $($_.Exception.Message)"
        Log-Error "OS check failed: $($_.Exception.Message)"
    }

    # 2) Hardware - CPU & GPU
    try {
        $cpu = Get-CimInstance Win32_Processor | Select-Object -First 1
        if ($cpu) {
            $cpuInfo = "$($cpu.Name) Cores:$($cpu.NumberOfCores) MaxClock:$($cpu.MaxClockSpeed)MHz"
            $windowsOutput += "SUCCESS: CPU detected: $cpuInfo"
            Log-Info "CPU: $cpuInfo"
        }
    } catch {
        $windowsOutput += "WARNING: CPU info unavailable."
        Log-Warn "CPU info unavailable: $($_.Exception.Message)"
    }
    try {
        $gpu = Get-CimInstance Win32_VideoController | Select-Object -First 1
        if ($gpu) {
            $gpuName = $gpu.Name
            $windowsOutput += "SUCCESS: GPU detected: $gpuName"
            Log-Info "GPU: $gpuName"
        }
    } catch {
        $windowsOutput += "WARNING: GPU info unavailable."
        Log-Warn "GPU info unavailable: $($_.Exception.Message)"
    }

    # 3) PowerShell modules signature scan (report only)
    $defaultModules = @("Microsoft.PowerShell.Archive", "Microsoft.PowerShell.Diagnostics", "Microsoft.PowerShell.Host",
        "Microsoft.PowerShell.LocalAccounts", "Microsoft.PowerShell.Management", "Microsoft.PowerShell.Security",
        "Microsoft.PowerShell.Utility", "PackageManagement", "PowerShellGet", "PSReadLine", "Pester", "ThreadJob")
    $modulesPath = "C:\Program Files\WindowsPowerShell\Modules"

    try {
        if (Test-Path $modulesPath) {
            $folders = Get-ChildItem $modulesPath -Directory -ErrorAction SilentlyContinue
            foreach ($m in $folders) {
                $isDefault = $defaultModules -contains $m.Name
                $files = Get-ChildItem $m.FullName -Recurse -File -ErrorAction SilentlyContinue
                $unauth = @()
                foreach ($f in $files) {
                    try {
                        $sig = Get-AuthenticodeSignature -FilePath $f.FullName -ErrorAction SilentlyContinue
                        if ($sig.Status -ne 'Valid' -or -not ($sig.SignerCertificate.Subject -match "Microsoft")) {
                            $unauth += $f
                        }
                    } catch {}
                }
                if ($unauth.Count -gt 0) {
                    $modulesOutput += "WARNING: Module '$($m.Name)' has $($unauth.Count) unsigned/altered file(s)."
                    Log-Warn "Module $($m.Name) has $($unauth.Count) unsigned files."
                } else {
                    $modulesOutput += "SUCCESS: Module '$($m.Name)' appears signed and valid."
                }
            }
        } else {
            $modulesOutput += "WARNING: Modules path not present: $modulesPath"
        }
    } catch {
        $modulesOutput += "WARNING: Module scan failed: $($_.Exception.Message)"
        Log-Warn "Module scan failed: $($_.Exception.Message)"
    }

    # 4) Memory integrity / HVCI
    try {
        $regPath = "HKLM:\SYSTEM\CurrentControlSet\Control\DeviceGuard\Scenarios\HypervisorEnforcedCodeIntegrity"
        if (Test-Path $regPath) {
            $enabled = Get-ItemPropertyValue -Path $regPath -Name "Enabled" -ErrorAction SilentlyContinue
            $memoryIntegrityOutput += "SUCCESS: Memory Integrity supported."
            if ($enabled -eq 1) {
                $memoryIntegrityOutput += "SUCCESS: Memory Integrity (HVCI) is ON."
            } else {
                $memoryIntegrityOutput += "FAILURE: Memory Integrity (HVCI) is OFF."
            }
            Log-Info "HVCI Enabled: $enabled"
        } else {
            $memoryIntegrityOutput += "FAILURE: Memory Integrity not supported or registry path missing."
            Log-Info "HVCI registry path missing."
        }
    } catch {
        $memoryIntegrityOutput += "WARNING: Memory Integrity check failed."
        Log-Warn "HVCI check failed: $($_.Exception.Message)"
    }

    # 5) Windows Defender status & exclusions (read-only)
    try {
        $def = Get-MpComputerStatus -ErrorAction Stop
        $svc = Get-Service -Name WinDefend -ErrorAction SilentlyContinue
        if ($def.AntivirusEnabled -and $svc.Status -eq 'Running') {
            if ($def.RealTimeProtectionEnabled) {
                $defenderOutput += "SUCCESS: Microsoft Defender running with realtime protection ON."
            } else {
                $defenderOutput += "WARNING: Defender realtime protection is OFF."
            }
        } else {
            $defenderOutput += "FAILURE: Microsoft Defender not running or disabled."
        }
        Log-Info "Defender status: AVEnabled=$($def.AntivirusEnabled) RTP=$($def.RealTimeProtectionEnabled)"
    } catch {
        $defenderOutput += "WARNING: Could not query Microsoft Defender status (insufficient rights or not present)."
        Log-Warn "Defender query failed: $($_.Exception.Message)"
    }

    try {
        $exclusions = @()
        $prefs = Get-MpPreference -ErrorAction SilentlyContinue
        if ($prefs) {
            if ($prefs.ExclusionPath) { $exclusions += $prefs.ExclusionPath }
            if ($exclusions.Count -gt 0) {
                $exclusionsOutput += "FAILURE: Defender exclusion paths found:`n$($exclusions -join "`n")"
                Log-Warn "Defender exclusions: $($exclusions -join ',')"
            } else {
                $exclusionsOutput += "SUCCESS: No Defender exclusion paths set."
                Log-Info "No Defender exclusions."
            }
        } else {
            $exclusionsOutput += "WARNING: Could not read Defender preferences."
        }
    } catch {
        $exclusionsOutput += "WARNING: Could not check Defender exclusions."
        Log-Warn "Defender exclusions check failed: $($_.Exception.Message)"
    }

    # 6) Threats (active)
    try {
        $threats = Get-MpThreat -ErrorAction SilentlyContinue | Where-Object { $_.Status -eq "Active" }
        if ($threats -and $threats.Count -gt 0) {
            foreach ($t in $threats) {
                $threatsOutput += "FAILURE: $($t.ThreatName) | $($t.Resources)"
                Log-Warn "Active threat: $($t.ThreatName) on $($t.Resources)"
            }
        } else {
            $threatsOutput += "SUCCESS: No active Defender threats detected."
            Log-Info "No active Mp threats."
        }
    } catch {
        $threatsOutput += "WARNING: Threat scan failed or not available."
        Log-Warn "Threat scan failed: $($_.Exception.Message)"
    }

    # 7) PowerShell binary signature
    try {
        $psPath = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
        if (Test-Path $psPath) {
            $sig = Get-AuthenticodeSignature -FilePath $psPath -ErrorAction SilentlyContinue
            if ($sig.Status -eq 'Valid' -and $sig.SignerCertificate.Subject -like '*Microsoft*') {
                $powershellSigOutput += "SUCCESS: PowerShell binary signature valid."
                Log-Info "PowerShell signature valid."
            } else {
                $powershellSigOutput += "FAILURE: PowerShell binary signature invalid/untrusted."
                Log-Warn "PowerShell signature invalid or untrusted."
            }
        } else {
            $powershellSigOutput += "WARNING: PowerShell binary not found at expected path."
            Log-Warn "PowerShell executable not found."
        }
    } catch {
        $powershellSigOutput += "WARNING: Could not verify PowerShell binary signature."
        Log-Warn "PowerShell sig check failed: $($_.Exception.Message)"
    }

    # 8) newui.exe scan (automatic as requested) - scan common roots & user-specified drives
    $drives = Get-PSDrive -PSProvider FileSystem | Select-Object -ExpandProperty Root
    $newuiFound = Scan-NewUI -Roots $drives -FastMode:$false
    if ($newuiFound.Count -gt 0) {
        $newuiFindings += $newuiFound
    }

    # Aggregate and display results
    function Write-Section {
        param([string]$Title, [string[]]$Lines)
        Write-ColoredLine "=== $Title ===" Cyan
        foreach ($line in $Lines) {
            if ($line -match "^SUCCESS") { Write-ColoredLine $line Green }
            elseif ($line -match "^FAILURE") { Write-ColoredLine $line Red }
            elseif ($line -match "^WARNING") { Write-ColoredLine $line Yellow }
            else { Write-ColoredLine $line White }
        }
        Write-Host ""
    }

    Write-Section "OS + Hardware" $windowsOutput
    Write-Section "Modules Scan" $modulesOutput
    Write-Section "Memory Integrity" $memoryIntegrityOutput
    Write-Section "Windows Defender" $defenderOutput
    Write-Section "Exclusions" $exclusionsOutput
    Write-Section "Threats" $threatsOutput
    Write-Section "PowerShell Binary Signature" $powershellSigOutput

    if ($newuiFindings.Count -gt 0) {
        Write-ColoredLine "=== newui.exe Findings ===" Red
        foreach ($f in $newuiFindings) {
            Write-ColoredLine " • $($f.Path)  (Size: $(Convert-BytesToReadable -Bytes $f.Size))" Yellow
        }
        Write-ColoredLine "`nRecommendation: Manually inspect the above file(s) and remove/quarantine if confirmed malicious." Yellow
        Log-Warn "newui.exe found during full system check."
    } else {
        Write-ColoredLine "newui.exe: No instances found." Green
        Log-Info "newui.exe not found in full system check."
    }

    # Success rate (simple metric)
    $allResults = $modulesOutput + $windowsOutput + $memoryIntegrityOutput + $defenderOutput + $exclusionsOutput + $threatsOutput + $powershellSigOutput
    $total = ($allResults | Where-Object { $_ -match '^(SUCCESS|FAILURE|WARNING)' }).Count
    $success = ($allResults | Where-Object { $_ -match '^SUCCESS' }).Count
    $rate = if ($total -gt 0) { [math]::Round(($success / $total) * 100, 0) } else { 0 }
    $rateColor = if ($rate -ge 75) { "Green" } elseif ($rate -ge 40) { "Yellow" } else { "Red" }

    Write-ColoredLine ""
    Write-ColoredLine $("Success Rate: $rate% ($success / $total)") $rateColor
    Log-Info "System check completed. SuccessRate=$rate"

    Wait-ForEnter -Message "Press Enter to return to the menu"
    Show-Menu
}

# ---------------------------
# Process Explorer installer/launcher (privileged actions)
# ---------------------------
function Run-ProcessExplorer {
    Clear-Host
    Show-AsyncTitle
    Write-ColoredLine "Step: Process Explorer Setup" White
    Write-ColoredLine "INSTRUCTION: This will download Process Explorer, extract it to C:\ToolsETA\ProcessExplorer and import a registry config." Yellow
    Write-Host ""

    # Ensure admin (we need to import registry and write to ProgramData / root)
    if (-not (Test-IsAdmin)) {
        Write-ColoredLine "[INFO] This action requires Administrator privileges. Relaunching..." Yellow
        Log-Info "Process Explorer setup requested; performing elevation."
        Ensure-RunningAsAdmin -RelaunchIfNotAdmin
        return
    }

    Show-LoadingBar -Cycles 6 -DelayMs 100

    $zipUrl = "https://download.sysinternals.com/files/ProcessExplorer.zip"
    $zipPath = Join-Path $ToolRoot "ProcessExplorer.zip"
    $regFileUrl = "https://pastebin.com/raw/gse8NxwU"
    $regFilePath = Join-Path $ToolRoot "procexp_config.reg"

    Try {
        Write-ColoredLine "[INFO] Downloading Process Explorer..." Cyan
        Invoke-WebRequest -Uri $zipUrl -OutFile $zipPath -UseBasicParsing -ErrorAction Stop
        Write-ColoredLine "[SUCCESS] Downloaded Process Explorer." Green
        Log-Info "Downloaded Process Explorer to $zipPath"
    } catch {
        Write-ColoredLine "[ERROR] Download failed: $($_.Exception.Message)" Red
        Log-Error "ProcessExplorer download failed: $($_.Exception.Message)"
        Wait-ForEnter -Message "Press Enter to return to menu"
        Show-Menu
        return
    }

    Try {
        Add-Type -ErrorAction SilentlyContinue -AssemblyName System.IO.Compression.FileSystem
        if (-not (Test-Path $ProcessExplorerFolder)) { New-Item -ItemType Directory -Path $ProcessExplorerFolder -Force | Out-Null }
        [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $ProcessExplorerFolder, $true)
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
        Write-ColoredLine "[SUCCESS] Extracted Process Explorer to $ProcessExplorerFolder" Green
        Log-Info "Extracted Process Explorer to $ProcessExplorerFolder"
    } catch {
        Write-ColoredLine "[WARN] Extraction failed or files already present: $($_.Exception.Message)" Yellow
        Log-Warn "Extract extraction warning: $($_.Exception.Message)"
    }

    # Download registry config
    Try {
        Write-ColoredLine "[INFO] Downloading Process Explorer registry configuration..." Cyan
        Invoke-WebRequest -Uri $regFileUrl -OutFile $regFilePath -UseBasicParsing -ErrorAction Stop
        Write-ColoredLine "[SUCCESS] Downloaded registry configuration." Green
        Log-Info "Downloaded reg config to $regFilePath"
    } catch {
        Write-ColoredLine "[WARN] Failed to download reg config: $($_.Exception.Message)" Yellow
        Log-Warn "Failed to download reg config: $($_.Exception.Message)"
    }

    # Import registry if file present
    try {
        if (Test-Path $regFilePath) {
            $cmdPath = Join-Path $env:SystemRoot "System32\cmd.exe"
            if (-not (Test-Path $cmdPath)) { throw "cmd.exe missing" }
            & $cmdPath /c "reg import `"$regFilePath`"" 2>&1 | Out-Null
            if ($LASTEXITCODE -eq 0) {
                Write-ColoredLine "[SUCCESS] Imported registry configuration." Green
                Log-Info "Imported Process Explorer registry config."
            } else {
                Write-ColoredLine "[WARN] reg import returned exit code $LASTEXITCODE." Yellow
                Log-Warn "reg import exit code $LASTEXITCODE"
            }
        } else {
            Write-ColoredLine "[WARN] Registry config not found; skipping import." Yellow
        }
    } catch {
        Write-ColoredLine "[WARN] Registry import failed: $($_.Exception.Message)" Yellow
        Log-Warn "Registry import failed: $($_.Exception.Message)"
    }

    # Launch process explorer exe
    $actualExe = Get-ChildItem -Path $ProcessExplorerFolder -Filter "procexp64.exe" -Recurse -File -ErrorAction SilentlyContinue | Select-Object -First 1
    if ($actualExe) {
        Write-ColoredLine "[INFO] Launching Process Explorer..." Cyan
        try {
            $proc = Start-Process -FilePath $actualExe.FullName -PassThru
            Start-Sleep -Milliseconds 700
            Write-ColoredLine "[SUCCESS] Process Explorer launched (PID $($proc.Id))." Green
            Log-Info "Launched Process Explorer: $($actualExe.FullName) PID=$($proc.Id)"
            Write-ColoredLine "Instruction: Scroll to the bottom of the window, then close it when finished." Yellow
            Write-ColoredLine "The script will continue after Process Explorer closes." Yellow
            $proc.WaitForExit()
            Write-ColoredLine "[SUCCESS] Process Explorer closed." Green
            Log-Info "Process Explorer closed by user."
        } catch {
            Write-ColoredLine "[ERROR] Failed to start Process Explorer: $($_.Exception.Message)" Red
            Log-Error "Failed to start Process Explorer: $($_.Exception.Message)"
        }
    } else {
        Write-ColoredLine "[ERROR] procexp64.exe not found after extraction." Red
        Log-Error "procexp64.exe not found at $ProcessExplorerFolder"
    }

    Wait-ForEnter -Message "Press Enter to return to the menu"
    Show-Menu
}

# ---------------------------
# View logs function
# ---------------------------
function View-Logs {
    Clear-Host
    Show-AsyncTitle
    Write-ColoredLine "Logs (tail - last 200 lines):" Cyan
    if (Test-Path $LogFile) {
        try {
            Get-Content -Path $LogFile -Tail 200 -ErrorAction Stop | ForEach-Object { Write-Host $_ }
        } catch {
            Write-ColoredLine "[ERROR] Could not read log file: $($_.Exception.Message)" Red
            Log-Error "View-Logs read failure: $($_.Exception.Message)"
        }
    } else {
        Write-ColoredLine "[INFO] No logs found yet. Run a scan to generate logs." Yellow
    }
    Wait-ForEnter -Message "Press Enter to return to the menu"
    Show-Menu
}

# ---------------------------
# Main interactive menu
# ---------------------------
function Show-Menu {
    Clear-Host
    Show-AsyncTitle
    Write-ColoredLine "=== MAIN MENU ===" Cyan
    Write-ColoredLine "[1] Full System Check" White
    Write-ColoredLine "[2] Process Explorer Setup" White
    Write-ColoredLine "[3] Scan for newui.exe (fast)" White
    Write-ColoredLine "[4] View Logs" White
    Write-ColoredLine "[5] Exit" DarkGray
    Write-Host ""
    $choice = Read-Host "Select an option (1-5)"
    switch ($choice) {
        "1" { Run-SystemCheck }
        "2" { Run-ProcessExplorer }
        "3" {
            # Quick scan on all filesystem drives (fast mode)
            $drives = Get-PSDrive -PSProvider FileSystem | Select-Object -ExpandProperty Root
            $res = Scan-NewUI -Roots $drives -FastMode
            if ($res.Count -eq 0) {
                Wait-ForEnter -Message "Press Enter to return to the menu"
                Show-Menu
            } else {
                Wait-ForEnter -Message "Press Enter to return to the menu"
                Show-Menu
            }
        }
        "4" { View-Logs }
        "5" { Write-ColoredLine "Goodbye!" Green; Exit 0 }
        default {
            Write-ColoredLine "Invalid selection." Red
            Start-Sleep -Seconds 1
            Show-Menu
        }
    }
}

# ---------------------------
# Entry point
# ---------------------------

# If script isn't running from a file path (interactive paste), $MyInvocation.MyCommand.Definition may be empty.
if (-not $PSCommandPath -and -not $MyInvocation.MyCommand.Definition) {
    # we are likely in the ISE or paste; still continue but warn for some actions needing script path
    Log-Warn "Script executed without a physical file path. Certain relaunch behaviors may not work."
}

# Start by ensuring admin if the action requires it — we'll allow menu first but certain options auto-elevate
Show-Menu
